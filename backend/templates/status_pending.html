<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Waiting for confirmation...</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Base page styling */
    body {
      background-color: #000;
      color: #58aaff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding-top: 8vh;
    }
    .pulse { font-size: 4rem; animation: pulse 1.5s infinite; margin-bottom: 1rem; }
    h1 { font-size: 2.2rem; margin-bottom: 0.5rem; }
    h2 { font-size: 1.1rem; margin-bottom: 2rem; }
    ul { list-style: none; padding: 0; font-size: 1.05rem; }
    li { margin: 8px 0; }
    button {
      margin-top: 1rem; padding: 0.5rem 1rem; background-color: #222; color: #58aaff;
      border: 1px solid #58aaff; border-radius: 5px; cursor: pointer;
    }
    .green { color: #00cc66; }
    .yellow { color: #ffcc00; }
    .red { color: #ff4444; }
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.1); }
      100% { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body>
  <!-- Status display -->
  <div class="pulse" id="statusEmoji">üåÄ</div>
  <h1 id="playerName">...</h1>
  <h2 id="statusText">Fetching status...</h2>

  <!-- Match checks -->
  <ul>
    <li id="match-startgg">Registered on Start.gg: ‚è≥</li>
    <li id="match-member">FGC Trollh√§ttan member: ‚è≥</li>
    <li id="match-payment">Payment confirmed: ‚è≥</li> <!-- was Swish -->
  </ul>

  <!-- Events + missing -->
  <ul id="matched-events-list" style="margin-top: 2rem;"></ul>
  <div id="missing-block" style="margin-top: 2rem;"></div>

  <button id="refreshBtn" onclick="updateStatus()">üîÑ Refresh manually</button>
  <p style="margin-top: 2rem;">This page refreshes every 10 seconds automatically.</p>

  <script>
    // Name is passed from backend template
    const name = "{{ name }}";

    // Guard to avoid overlapping polls
    let inFlight = false;
    let pollCount = 0;
    const MAX_POLLS = 30; // 30 * 10s = 5 minutes max

    // Helpers
    const setText = (id, text) => {
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    };

    // Update a check row preserving its left label
    const setCheck = (id, ok) => {
      const el = document.getElementById(id);
      if (!el) return;
      const label = el.textContent.split(":")[0];
      el.textContent = `${label}: ${ok ? "‚úì" : "‚úó"}`;
      el.className = ok ? "green" : "red";
    };

    // Flag to stop polling (e.g., already checked in - status won't change from polling)
    let stopPolling = false;
    let intervalId = null;

    async function updateStatus() {
      if (inFlight || stopPolling) return;

      // Check polling timeout
      pollCount++;
      if (pollCount > MAX_POLLS) {
        setText("statusText", "Timeout - please refresh manually");
        stopPolling = true;
        if (intervalId) clearInterval(intervalId);
        return;
      }

      inFlight = true;
      document.getElementById("refreshBtn").disabled = true;

      try {
        // Poll backend API endpoint (checks Airtable for member/payment/startgg)
        const res = await fetch(`/api/participant/${encodeURIComponent(name)}/status`, {
          method: "GET",
          cache: "no-store",
        });
        if (!res.ok) throw new Error(`Server responded ${res.status}`);

        const data = await res.json();

        // If ready -> redirect to success page
        if (data?.ready) {
          // Cleanup sensitive data on success
          localStorage.removeItem("personnummer");
          localStorage.removeItem("telefon");
          window.location.href = `/status/${encodeURIComponent(name)}`;
          return;
        }

        // Render current state
        setText("playerName", data?.name ?? name ?? "Unknown");

        // Check if already checked in - show friendly message and stop polling
        // (Status won't change from polling - only TO can approve payment)
        if (data?.already_checked_in || pollCount > 1) {
          setText("statusText", "Checked in - awaiting TO approval");
          stopPolling = true;
          if (intervalId) clearInterval(intervalId);
          // Update the auto-refresh message
          document.querySelector("p[style*='margin-top: 2rem']").textContent =
            "Use the refresh button to check for updates.";
        } else {
          setText("statusText", data?.status ?? "Pending...");
        }

        const isReady = data?.status === "Ready";
        const emojiEl = document.getElementById("statusEmoji");
        emojiEl.textContent = isReady ? "‚úì" : "‚è≥";
        emojiEl.className = "pulse " + (isReady ? "green" : "yellow");

        setCheck("match-startgg", !!data?.startgg);
        setCheck("match-member", !!data?.member);
        setCheck("match-payment", !!data?.payment);

        // Registered events
        const eventsList = document.getElementById("matched-events-list");
        if (Array.isArray(data?.startgg_events) && data.startgg_events.length > 0) {
          eventsList.innerHTML =
            `<p class="green">Registered in:</p>` +
            data.startgg_events.map(ev => `<li class="green">${ev}</li>`).join("");
        } else {
          eventsList.innerHTML = "";
        }

        // Missing items
        const missing = Array.isArray(data?.missing) ? data.missing : [];
        const block = document.getElementById("missing-block");
        if (missing.length > 0) {
          block.innerHTML =
            `<p class="yellow">Missing:</p><ul>` +
            missing.map(s => `<li class="red">${s}</li>`).join("") +
            `</ul>`;
        } else {
          block.innerHTML = "";
        }

      } catch (err) {
        setText("statusText", "Could not connect to server");
        const emojiEl = document.getElementById("statusEmoji");
        emojiEl.textContent = "‚úó";
        emojiEl.className = "pulse red";
        console.error("updateStatus failed:", err);
      } finally {
        inFlight = false;
        document.getElementById("refreshBtn").disabled = false;
      }
    }

    // Start with one immediate check, then poll every 10s (but stop after first successful response)
    updateStatus();
    intervalId = setInterval(updateStatus, 10000);

    // === SSE for real-time updates from TO ===
    let eventSource = null;

    function connectSSE() {
      const sseUrl = '/api/events/stream';
      console.log('Connecting to SSE for real-time updates...');

      try {
        eventSource = new EventSource(sseUrl);

        eventSource.onopen = function() {
          console.log('SSE connected - will auto-refresh on TO updates');
        };

        eventSource.addEventListener('update', function(e) {
          console.log('SSE update received:', e.data);
          // TO made a change - refresh status
          stopPolling = false; // Re-enable to fetch new data
          updateStatus();
          stopPolling = true; // Stop again after update
        });

        eventSource.addEventListener('checkin', function(e) {
          console.log('SSE checkin event:', e.data);
          // Something changed - refresh
          stopPolling = false;
          updateStatus();
          stopPolling = true;
        });

        eventSource.onerror = function(e) {
          console.log('SSE error, will retry...');
          if (eventSource.readyState === EventSource.CLOSED) {
            setTimeout(connectSSE, 5000);
          }
        };
      } catch (err) {
        console.error('SSE not available:', err);
      }
    }

    // Connect to SSE after initial status check
    setTimeout(connectSSE, 2000);
  </script>
</body>
</html>
